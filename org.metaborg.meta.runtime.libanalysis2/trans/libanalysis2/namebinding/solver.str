module libanalysis2/namebinding/solver

imports
  
  libanalysis2/namebinding/-
  libanalysis2/prelude/-
  libanalysis2/solver/-
  libanalysis2/pp
  src-gen/signatures/libanalysis2/-

rules
 
  solve-fact: (FDecl(d,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-decl> (g,s,d) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-fact: (FRef(r,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-ref> (g,s,r) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-fact: (FImportR(r,l,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-r-import> (g,s,(r,l)) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-fact: (FImportS(s',l,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-s-import> (g,s,(s',l)) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-fact: (FParent(s,p),sol-wm)   -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-parent> (g,s,p) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-fact: (FAssoc(d,s),sol-wm)    -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-assoc> (g,d,s) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

rules

  solve-constraint: (CResolves(r,l,d,pos),sol-wm) -> [(sol-wm,c*)]
  where <fromWM;sol-r> sol-wm => r*
      ; <lookup> (r,r*) => (d',l')
  with c* := [ CEqual(d,d',pos),
               CEqual(l,l',pos)
             ]

  solve-constraint: (CResolves(r,l,d,pos),sol-wm) -> res*
  where <fromWM;sol-r> sol-wm => r*
      ; <not(lookup)> (r,r*)
      ; <fromWM;sol-g> sol-wm => g
      ; <resolve(|g)> r => Total(dl*@[_|_])
  with <map(solve-namebinding-constraint-step(|r,l,d,pos,sol-wm))> dl* => res*

  solve-namebinding-constraint-step(|r,l,d,pos,sol-wm): (d',l') -> (sol-wm',c*)
  with <fmap(sol-set-r(|r,(d',l')))> sol-wm => sol-wm'
  with c* := [ CEqual(d,d',pos)
             , CEqual(l,l',pos)
             ]
 
  solve-constraint: (CAssoc(d,s,pos),sol-wm) -> [(sol-wm,c*)]
  where <is-ground> d
      ; <fromWM;sol-g> sol-wm => g
      ; <G-assoc> (g,d) => s'
  with c* := [ CEqual(s,s',pos) ]
 
  solve-constraint: (CDistinct(s,pos),sol-wm) -> [(sol-wm',[])]
  where <is-ground> s
      ; <sol-g> sol-wm => g
      ; <G-decls;map(atom)> (g,s) => d*
  with ( <dups> d* => d'*
       < <add-error(|(pos,$[Duplicate declarations [<write-to-string> d'*]]))> sol-wm
       + !sol-wm
       ) => sol-wm'

  solve-constraint: (CInit(s,pos),sol-wm) -> [(sol-wm',[])]
  where <is-ground> s
      ; <sol-g> sol-wm => g
      ; <G-refs;map(atom)> (g,s) => r*
      ; <env_v(|g,[],[]);fmap(keys)> s => Total(d*)
  with <isect> (r*,d*) => i*
     ; ( ?[]
       < !sol-wm
       + <add-error(|(pos,$[Mismatch [<write-to-string> i*]]))> sol-wm
       ) => sol-wm'

rules
 
  unsolved-error: CResolves(r,l,d,pos) -> (pos,$[Could not resolve [<pp-RefId> r] to [<pp-DeclId> d]])
  unsolved-error: CAssoc(d,s,pos) -> (pos,$[Could not find associated scope [<pp-Scope> s] of [<pp-DeclId> d]])
