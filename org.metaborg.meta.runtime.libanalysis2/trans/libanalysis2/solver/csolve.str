module libanalysis2/solver/csolve

rules

  // solve : (c,e) -> [(e,[c])]
  // preprocess : (e,c) -> c
  // postprocess : (e,[c]) -> e

rules
 
  // csolve :: (e,[c]) -> [(e,[c])]
  csolve(preprocess,solve) =
    ( !(<Fst>,<Snd>,[])
    ; csolve-first(preprocess,solve)
    ; map( !(<Fst>, <conc> (<Snd>,<Third>))
         ; csolve(preprocess,solve)
         )
    ; concat
   <+ ![<id>]
    )

rules

  // csolve-first :: (e,[c],[c]) -> [(e,[c],[c])]
  csolve-first(preprocess,solve): (e,[c|c*],c'*) -> ecc*
    where <csolve-one(preprocess,solve)> (e,c) => ec*
    with <map(!(<Fst>,<conc> (<Snd>,c*),c'*))> ec* => ecc*

  csolve-first(preprocess,solve): (e,[c|c*],c'*) -> <csolve-first(preprocess,solve)> (e,c*,[c|c'*])

rules
  
  // csolve-one :: (e,c) -> [(e,[c])]
  csolve-one(preprocess,solve): (e,c) -> ec*
    with <preprocess> (e,c) => c'
    where <solve> (c',e) => ec*

rules

  preprocess-default: (_,c) -> c
