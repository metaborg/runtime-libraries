module libanalysis2/nabl2/nabl2

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  src-gen/signatures/libanalysis2/-
  libanalysis2/positioning/functions
  libanalysis2/pp
  
rules
  
  nabl2-constraint(|facts, constraints, scopes, position) = fail
  nabl2-scope(|facts, constraints, scopes, position) = fail
  
rules

  do-extract-constraint =
    ?ast;
    // Ensure all dynamic rules are properly scoped
    {| NewScope, NewVar, NewImplicit:
	    scope-counter    := <new-counter>;
	    var-counter      := <new-counter>;
	    implicit-counter := <new-counter>;
	    rules( NewScope: _ -> <next-counter> scope-counter
	           NewVar: _ -> <next-counter> var-counter
	           NewImplicit: _ -> <next-counter> implicit-counter
	         );
	    facts := <new-iset>;
	    constraints := <new-iset>;
	    tvars := <new-hashtable>;
	    ast' := <
	    	annotate-keys; 
	      nabl2-traverse(|facts, constraints, [Global()], <get-position>)> ast;
	    f* := <iset-elements> facts;
	    c* := <iset-elements> constraints
	  |};
    !(ast', [f*, c*])

  nabl2-traverse(|facts, constraints, scopes, position) =
  	with(position' := <get-position <+ !position>)
  ; (  dbg-nabl2(|"enter ");
       nabl2-constraint(|facts, constraints, scopes, position'); dbg-nabl2(|"custom constraint rule successful ")
	  <+ nabl2-scope(|facts, constraints, scopes, position'); dbg-nabl2(|"custom scope rule successful ")
	  <+ dbg-nabl2(|"custom rule failed "); nabl2-traverse-children(|facts, constraints, scopes, position'); dbg-nabl2(|"generic rule successful ")
	  <+ <dbg-nabl2(|"generic rule failed ")> scopes ; fail 
	  )
  
  nabl2-traverse-children(|facts, constraints, scopes, position) =
    with(
    	get-arguments;
    	map(nabl2-traverse(|facts, constraints, scopes, position))
    )

  type-app = ?Var(_)
  type-app = ?TVar(_)
  type-app = is-string
  type-app = is-int
  type-app = !TList(<is-list>)
  type-app = debug(!"ERROR: Maybe forgot signature for ") ; fail
  
  type-of-constraints(|ty, msg):
    l* -> [CEqual(ty, TList(tv*), msg), c*]
    where
      dbg-nabl2(|"list "); is-list
    with
      tv* := <map(!Var(<NewVar>))> l*
    ; c*  := <zip(!CTypeOf(<Fst; get-position>, <Snd>, msg))> (l*, tv*)
  
  new-var = !Var(<NewVar>)
  
  get-implicit-decl-position(|term) = id
  /*
    Pos(_, f, _, _, _, _) -> Pos($[[s][<NewImplicit>]], f, -1, -1, -1, -1)
    with
      s := <term-to-string> term
  */
  
  get-implicit-ref-position(|term) = id
  /*
    Pos(k, f, _, _, _, _) -> Pos($[[s][k]], f, -1, -1, -1, -1)
    with
      s := <term-to-string> term
  */
  
  term-to-string = is-string <+ get-constructor <+ int-to-string
  
rules
  
  dbg-nabl2(s|n) = id // s ; debug(!n)
  dbg-nabl2(|n) = dbg-nabl2(id|n)
  dbg-nabl2(s) = dbg-nabl2(s|"")
  dbg-nabl2 = dbg-nabl2(id|"")
