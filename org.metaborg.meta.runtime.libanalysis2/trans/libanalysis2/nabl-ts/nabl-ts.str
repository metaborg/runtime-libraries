module libanalysis2/nabl-ts/nabl-ts

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  src-gen/signatures/libanalysis2/-
  libanalysis2/pp

rules
  
  // nabl-ts-constraint(|iset,Scope) :: Term -> Term
  nabl-ts-constraint(|constraints,scopes) = ?t ; <debug(!"Unmatched: ")> (scopes,t) ; fail

rules

  do-extract-constraint =
    ?ast;
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start;
    scope-counter := <new-counter>;
    decl-var-counter := <new-counter>;
    scope-var-counter := <new-counter>;
    type-var-counter := <new-counter>;
    rules( NewScope: _ -> <next-counter> scope-counter
           NewScopeVar: _ -> <next-counter> scope-var-counter
           NewDeclVar: _ -> <next-counter> decl-var-counter
           NewTVar: _ -> <next-counter> type-var-counter
         );
    constraints := <new-iset>;
    <nabl-ts-traverse(|constraints,[Global()])> ast => ast';
    c* := <iset-elements> constraints;
    try(dr-scope-all-end);
    !(ast',c*)

  nabl-ts-traverse(|constraints,scopes) =
       nabl-ts-constraint(|constraints,scopes)
    <+ nabl-ts-traverse-children(|constraints,scopes)

  nabl-ts-traverse-children(|constraints,scopes) =
    ?t@c#(p*){a*};
    p'* := <map(nabl-ts-traverse(|constraints,scopes))> p*;
    t'' := <try( ?t'
               ; o := <origin-location-offset> t
               ; <origin-location-offset-set(|o)> t' )> c#(p'*){a*};
    !t''
