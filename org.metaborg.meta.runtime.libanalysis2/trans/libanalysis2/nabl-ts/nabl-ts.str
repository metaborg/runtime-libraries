module libanalysis2/nabl-ts/nabl-ts

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  src-gen/signatures/libanalysis2/-
  libanalysis2/abstract-syntax/-
  libanalysis2/pp
  
rules
  
  nabl-ts-constraint(|facts, constraints, scopes, position) = fail
  
rules

  do-extract-constraint =
    ?ast;
    // Ensure all dynamic rules are properly scoped
    dr-begin-scopes(|["NewScope","NewVar"]);
    scope-counter := <new-counter>;
    var-counter := <new-counter>;
    rules( NewScope: _ -> <next-counter> scope-counter
           NewVar: _ -> <next-counter> var-counter
         );
    facts := <new-iset>;
    constraints := <new-iset>;
    tvars := <new-hashtable>;
    ast' := <
    	annotate-keys; 
      nabl-ts-traverse(|facts, constraints, [Global()], <get-position>)> ast;
    f* := <iset-elements> facts;
    c* := <iset-elements> constraints;
    try(dr-end-scopes(|["NewScope","NewVar"]));
    !(ast', [f*, c*])

  nabl-ts-traverse(|facts, constraints, scopes, position) =
  	with(position' := <get-position <+ !position>)
  ; (  debug(!"enter "); nabl-ts-constraint(|facts, constraints, scopes, position'); debug(!"custom rule successful ")
	  <+ debug(!"custom rule failed "); nabl-ts-traverse-children(|facts, constraints, scopes, position'); debug(!"generic rule successful ")
	  <+ <debug(!"generic rule failed ")> scopes ; fail 
	  )
  
  nabl-ts-traverse-children(|facts, constraints, scopes, position) =
    with(
    	get-arguments;
    	map(nabl-ts-traverse(|facts, constraints, scopes, position))
    )

  type-app = ?Var(_)
  type-app = !TList(<is-list>)
  
  type-of-constraints(|ty, msg):
    l* -> [CEqual(ty, TList(tv*), msg), c*]
    where
      debug(!"list "); is-list
    with
      tv* := <map(!Var(<NewVar>))> l*
    ; c*  := <zip(!CTypeOf(<Fst; get-position>, <Snd>, msg))> (l*, tv*)
    