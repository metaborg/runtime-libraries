module libanalysis2/nabl-ts/nabl-ts

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  src-gen/signatures/libanalysis2/-
  libanalysis2/pp

rules
  
  nabl-ts-constraint(|tvars, facts, constraints, scopes) = fail

rules

  do-extract-constraint =
    ?ast;
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start;
    scope-counter := <new-counter>;
    decl-var-counter := <new-counter>;
    scope-var-counter := <new-counter>;
    type-var-counter := <new-counter>;
    rules( NewScope: _ -> <next-counter> scope-counter
           NewScopeVar: _ -> <next-counter> scope-var-counter
           NewDeclVar: _ -> <next-counter> decl-var-counter
           NewTVar: _ -> <next-counter> type-var-counter
         );
    facts := <new-iset>;
    constraints := <new-iset>;
    tvars := <new-hashtable>;
    ast' := <
    	annotate-keys; 
      nabl-ts-traverse(|tvars, facts, constraints, [])> ast;
    f* := <iset-elements> facts;
    c* := <iset-elements> constraints;
    try(dr-scope-all-end);
    !(ast', [f*, c*])

  annotate-keys = topdown(annotate-key)
  
  annotate-key: t -> t{<newname> ""}
  
  nabl-ts-traverse(|tvars, facts, constraints, scopes) =
     nabl-ts-constraint(|tvars, facts, constraints, scopes)
  <+ nabl-ts-traverse-children(|tvars, facts, constraints, scopes)

  nabl-ts-traverse-children(|tvars, facts, constraints, scopes) =
    with(
    	get-arguments;
    	map(nabl-ts-traverse(|tvars, facts, constraints, scopes))
    )
    
  get-type-var(|tvars) =
  	[key] := <get-annos>
  ; (    <hashtable-get(|key)> tvars 
      <+ with(tvar := <NewTVar>)
       ; <hashtable-put(|key, tvar)> tvars
    )
   ; !tvar