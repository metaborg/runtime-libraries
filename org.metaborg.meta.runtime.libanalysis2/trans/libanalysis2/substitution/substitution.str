module libanalysis2/substitution/substitution

imports

  libanalysis2/prelude/-
  libanalysis2/namebinding/-
  libanalysis2/typechecking/-
  libanalysis2/solver/-
  libanalysis2/pp
  src-gen/signatures/libanalysis2/-
 
rules
 
  is-var: Var(_) -> <id>
  all-vars = collect-all(is-var)

  is-op = fail
  reduce-op(|x*) = fail
  reduce-ops(|x*) = innermost(reduce-op(|x*))

  is-ground = where(collect-all(is-var <+ is-op) => [])

rules
  
  unify-wm(|pos): (_,_) -> <unify;pureWM>
  unify-wm(|pos): (t1,t2) ->  <pureWM;add-error(|(pos,msg))> []
  with msg := $[Cannot unify [<pp-Analysis-string> t1] and [<pp-Analysis-string> t2]]

  unify: (t,t) -> []
  unify: (v@Var(_),t) -> [(v,t)]
  unify: (t,v@Var(_)) -> [(v,t)]
  unify: (c#(a1*), c#(a2*)) -> <zip;S-foldr(![],unify)> (a1*, a2*)

rules

  // S-foldr(s0: s, s: a -> s) :: [a] -> s
  S-foldr(s0,s) = foldr(s0,S-foldr-step(s))
  // S-foldr-step(s: a -> s) :: (a,s) -> s
  S-foldr-step(s): (t,s) -> s''
  where <S-apply;s> (s,t) => s'
      ; <S-compose> (s',s) => s''

  S-compose: s* -> s
  where is-list
  with s := <foldr([],S-compose)> s*

  S-compose: (s',s) ->  <conc> (s', <mapv(<S-apply> (s',<id>))> s)

  S-apply: (s,t) -> t'
  with <S-safe> s => s'
     ; <topdown( try( is-var ; <lookup> (<id>,s') ) )> t => t'

  S-safe: s -> s'
  with <filter(not(S-occurs))> s => s'

  S-unsafe: s -> s'
  with <filter(S-occurs)> s => s'

  S-occurs: (v,t) -> <id>
  where <elem> (v, <all-vars> t)

rules
  
  pp-S = map((pp-Analysis-string,pp-Analysis-string))
