module libanalysis2/unification/functions

imports

  libanalysis2/prelude/-
  libanalysis2/pp
  libanalysis2/solver/varops
  src-gen/signatures/libanalysis2/-
 
rules

  // S-foldr(s0: s, s: a -> s) :: [a] -> s
  S-foldr(s0,s) = foldr(s0,S-foldr-step(s))
  // S-foldr-step(s: a -> s) :: (a,s) -> s
  S-foldr-step(s): (t,s) -> s''
  where <S-apply;s> (s,t) => s'
      ; <S-compose> (s',s) => s''

  S-compose: s* -> s
  where is-list
  with s := <foldr([],S-compose)> s*

  S-compose: (s',s) ->  <conc> (s', <mapv(<S-apply> (s',<id>))> s)

  S-apply: (s,t) -> t'
  with <S-safe> s => s'
     ; <topdown( try( is-var ; <lookup> (<id>,s') ) )> t => t'

  S-safe: s -> s'
  with <filter(not(S-occurs))> s => s'

  S-unsafe: s -> s'
  with <filter(S-occurs)> s => s'

  S-occurs: (v,t) -> <id>
  where <elem> (v, <all-vars> t)

rules
  
  pp-S = map((pp-Analysis-string,pp-Analysis-string))
