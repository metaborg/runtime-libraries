module libanalysis2/Analysis

imports

  libanalysis2/Common

sorts

  Scope
  OptionScope
  DeclId
  RefId
  Pos
  Namespace

context-free syntax

  Var.Var                   = <v<Int>>

  Scope.Global              = <global>
  Scope.Scope               = <scope(<Int>)>
  Scope                     = Var

  OptionScope.NoneScope     = <->
  OptionScope.SomeScope     = <<Scope>>

  DeclId.DeclId             = <decl(<Namespace>,<String>,<Pos>)>
  DeclId                    = Var

  RefId.RefId               = <ref(<Namespace>,<String>,<Pos>)>

  Pos.Pos                   = <<String>@(<String>,<Int>,<Int>,<Int>,<Int>)>
  Pos.POfDecl               = <posOf(<DeclId>)>
  Pos.POfRef                = <posOf(<RefId>)>

  Namespace.None            = <->

sorts

  Type
  TypeDef
  TypeArg
  Variance
  TypeCon

context-free syntax

  Type.TApp                 = <<TypeCon>[<{Type ","}*>]>
  Type                      = Var
  Type.TList                = <[<{Type ", "}*>]>
  TypeDef.TDef              = <<TypeCon>[<{TypeArg ","}*>]>
  TypeArg.TArg              = <<Variance><Type>>

  Variance.Invariant        = <=>
  Variance.Covariant        = <+>
  Variance.Contravariant    = <->

  TypeCon                   = NotImplemented

sorts

  Constraint
  Substitution

context-free syntax

  Constraint.CTrue          = <T>
  Constraint.CAndStar       = <<{Constraint "/\\"}*>> {longest-match}

  Constraint.FDecl          = <<DeclId> in <Scope>>
  Constraint.FRef           = <<RefId> in <Scope>>
  Constraint.FImportR       = <import <RefId><Term> in <Scope>>
  Constraint.FImportS       = <import <Scope><Term> in <Scope>>
  Constraint.FParent        = <parent(<Scope>) is <OptionScope>>
  Constraint.FAssoc         = <<DeclId> with <Scope>>

  Constraint.FSubType       = [[TypeDef] <: [Type] [Pos]]

  Constraint.CResolves      = [[RefId] |-[Term]-> [DeclId] [Pos]]
  Constraint.CEqType        = [[Type] == [Type] [Pos]]
  Constraint.CLubType       = [[Type] == lub([Type],[Type]) [Pos]]
  Constraint.CSubType       = [[Type] <= [Type] [Pos]]
  Constraint.CAssoc         = [[DeclId] ~~> [Scope] [Pos]]
  Constraint.CTypeOf        = <<Pos> : <Type> <Pos>>

  Constraint.CMkSub         = [[Substitution] == {[TypeList] |-->* [TypeList]} [Pos]]
  Constraint.CComposeSub    = <<Substitution> == <SubstitutionList> <Pos>>
  Constraint.CApplySub      = <<Type> == <Substitution>.<Type> <Pos>>

  Substitution.Sub          = <{<{Mapping ","}*>}>
  Substitution              = Var

//-------------------
// Ordering is a bit sensitive here, so prettyprinting works reasonably well
// Term needs to go after all rules for constructors, because it will succeed
// on anything. Rules without constructors (which produce unwrapped lists or
// tuples) need to go after Term, so they won't break.

lexical syntax

  Term           = ~[]+

sorts

  TypeList
  Mapping
  SubstitutionList

context-free syntax

  TypeList                  = <[<{Type ","}*>]>
  TypeList                  = Var

  Mapping                   = [[Type] |--> [Type]]

  SubstitutionList          = <[<{Substitution ","}*>]>
  SubstitutionList          = Var
