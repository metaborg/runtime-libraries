module libanalysis2/Analysis

imports

  libanalysis2/Common

context-free syntax

  Var.Var                   = <v<Int>>

  Scope.Global              = <global>
  Scope.Scope               = <scope(<Int>)>
  Scope                     = Var

  OptionScope.NoneScope     = <->
  OptionScope.SomeScope     = <<Scope>>

  DeclId.DeclId             = <decl(<Namespace>,<String>,<Pos>)>
  DeclId                    = Var

  RefId.RefId               = <ref(<Namespace>,<String>,<Pos>)>

  Pos.Pos                   = <<String>@(<String>,<Int>,<Int>,<Int>,<Int>)>
  Pos.POfDecl               = <posOf(<DeclId>)>
  Pos.POfRef                = <posOf(<RefId>)>

  Namespace.None            = <->
  Namespace.Namespace       = String

  Atom.Atom                 = <atom(<Namespace>,<String>)>

  ErrorInfo                 = Pos

context-free syntax

  Type.TApp                 = <<TypeCon>[<{Type ","}*>]>
  Type.TVar                 = <'<String>>
  Type.TList                = <TY[<{Type ", "}*>]>
  Type                      = Var

  TypeDef.TDef              = <<TypeCon>[<{TypeArg ","}*>]>
  TypeArg.TArg              = <<Variance><Type>>

  Variance.Invariant        = <=>
  Variance.Covariant        = <+>
  Variance.Contravariant    = <->

  TypeCon                   = NotImplemented

context-free syntax // unification

  Constraint.CTrue          = <T>
  Constraint.CAndStar       = <<{Constraint "/\\"}*>> {longest-match}
  Constraint.CEqual        = [[Term] == [Term] [ErrorInfo]]

context-free syntax // types

  Constraint.CTypeOf        = <<Pos> : <Type> <ErrorInfo>>

context-free syntax // name resolution

  Constraint.FDecl          = <<DeclId> in <Scope>>
  Constraint.FRef           = <<RefId> in <Scope>>
  Constraint.FImportR       = <import <RefId><Term> in <Scope>>
  Constraint.FImportS       = <import <Scope><Term> in <Scope>>
  Constraint.FParent        = <parent(<Scope>) is <OptionScope>>
  Constraint.FAssoc         = <<DeclId> with <Scope>>

  Constraint.CResolves      = [[RefId] |-[Term]-> [DeclId] [ErrorInfo]]
  Constraint.CAssoc         = [[DeclId] ~~> [Scope] [ErrorInfo]]
  Constraint.CDistinct      = <distinct <Scope> <ErrorInfo>>
  Constraint.CInit          = <init <Scope> <ErrorInfo>>

context-free syntax // subtyping

  Constraint.FSubType       = [[TypeDef] <: [Type] [ErrorInfo]]

  Constraint.CLubType       = [[Type] == lub([Type],[Type]) [ErrorInfo]]
  Constraint.CSubType       = [[Type] <= [Type] [ErrorInfo]]

context-free syntax // substitutions

  Constraint.CMkSub         = [[Substitution] == [Type] |-->* [Type] [ErrorInfo]]
  Constraint.CComposeSub    = <<Substitution> == <{Substitution " . "}+> <ErrorInfo>>
  Constraint.CApplySub      = <<Type> == <Substitution>.<Type> <ErrorInfo>>

  Mapping                   = [[Type] |--> [Type]]

  Substitution.Sub          = <{<{Mapping ","}*>}>
  Substitution              = Var
