module libanalysis2/typechecking/solver

imports
  signatures/libanalysis2/equality/-
  signatures/libanalysis2/typechecking/-
  libanalysis2/solver/-
  libanalysis2/typechecking/-
  libanalysis2/prelude/-
  libanalysis2/pp

rules
 
  solve-constraint: (f@FSubType(tyd@TDef(tc,_),ty,msginfo),sol-wm) -> [(sol-wm',[])]
  where <is-ground> (tyd,ty)
      ; <fromWM;sol-x> sol-wm => x*
      ; <build-subtype-relation(|x*)> (tyd,ty) => sr
  with ( <lookup> (tc, x*)
       < msg := $[Duplicate fact [<pp-Constraint> f]]
       ; <add-message(detail-message(|msg)|msginfo)> sol-wm
       + <fmap(<sol-set-x(|sr)> (tc,<id>))> sol-wm
       ) => sol-wm'

rules

  solve-constraint: (CSubType(TList(ty1*),TList(ty2*),msginfo),sol-wm) -> [res]
  where <is-list> ty1*
      ; <is-list> ty2*
  with ( <(length,length);eq> (ty1*,ty2*)
       < msg := [ty1*," not a subtype of ",ty2*]
       ; msginfo' := <detail-message(|msg)> msginfo
       ; !(sol-wm, <zip;map(!CSubType(<Fst>,<Snd>,msginfo'))> (ty1*,ty2*))
       + msg := ["Cannot check subtyping for lists [",ty1*,"] and [",ty2*,"] of different length."]
       ; !(<add-message(detail-message(|msg)|msginfo)> sol-wm, [])
       ) => res

  solve-constraint: (CSubType(ty1@TApp(_,_),ty2@TApp(_,_),msginfo),sol-wm) -> [res]
  where <is-ground> (ty1,ty2)
  with <fromWM;sol-x> sol-wm => x*
     ; msg := [ty1," is not a subtype of ",ty2]
     ; msginfo' := <detail-message(|msg)> msginfo
     ; ( <is-subtype-traverse(!CEqual(<Fst>,<Snd>,msginfo')
                             ,!CSubType(<Fst>,<Snd>,msginfo')
                             ,!CSubType(<Snd>,<Fst>,msginfo')
                             ,id|x*);Snd> (ty1,ty2) => c*
       < !(sol-wm,c*)
       + !(<add-message(detail-message(|msg)|msginfo)> sol-wm, [])
       ) => res

rules

  is-op = ?Lub(_,_)

  reduce-op(|sol-wm): Lub(ty,ty) -> ty

  reduce-op(|sol-wm): ty@Lub(ty1@TApp(_,_),ty2@TApp(_,_)) -> lub
  where <is-ground> (ty1,ty2)
  with <fromWM;sol-x> sol-wm => x*
  where <all-tcs;map(<lookup> (<id>, x*))> (ty1,ty2)
      ; ( <lub(|x*)> (ty1,ty2) => lub
       <+ add-reduce-error(|["Types ",ty1," and ",ty2," have no least upper bound."])
        )

rules

  constraint-priority: FSubType(_,_,_) -> 5
  constraint-priority: CSubType(_,_,_) -> 6

rules

  constraint-message: FSubType(ty1,ty2,msginfo) -> <default-message(|["Failed to register ",ty1," as subtype of ",ty2])> msginfo

  constraint-message: CSubType(ty1,ty2,msginfo) -> <default-message(|["Failed to check if ",ty1," is a subtype of ",ty2])> msginfo
