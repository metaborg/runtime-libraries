module libanalysis2/typechecking/functions

imports
  libanalysis2/prelude/-
  libanalysis2/pp
  libanalysis2/typechecking/-
  libanalysis2/equality/functions
  signatures/libanalysis2/typechecking/-

signature
  sorts
    Kind
    SubtypeRelation
  constructors
    : (TypeCon,List(Type)) -> SuperType
    : List(TypeCon,(List(Variance),List(SuperType))) -> SubtypeRelation

rules

  is-tvar = ?TVar(_)

  build-subtype-rel = fail
  subtype-variance  = fail
  
  new-nabl2-subtype-relation = 
    new-hashtable => table
  ; try(build-subtype-rel)
  ; hashtable-keys
  ; where( map(\ key -> <repeat(extend-subtype-relation(|key))> table \) )
  ; map(subtype-entry(|table))
  ; where(<hashtable-destroy> table)
  
  extend-subtype-relation(|type) =
     ?table
   ; hashtable-get(|<debug(!"update ")> type) => type*
   ; filter(lookup-entries(|table)); unions => type'*
   ; <diff; debug(!"new ")> (type'*, type*) => [_|_] 
   ; <hashtable-put(|type, type'*)> table
  
  subtype-entry(|table):
    type -> <debug> (type, (var*, type*)) 
    with
      var*  := <subtype-variance> type
    ; type* := <hashtable-get(|type); reverse> table 
  
  lookup-entries(|table):
    (tc, []) -> <hashtable-get(|tc)> table
      
  build-subtype-relation(|x*): (TDef(tc,ta*),TApp(tc,a*)) -> sr
  where <(length,length);eq> (ta*,a*)
  with <map(ta-variance)> ta* => v*
     ; <map(ta-type)> ta* => a*
     ; sr := ( v*, [ (tc, a*) ] )

  build-subtype-relation(|x*): (TDef(tc1,ta1*),TApp(tc2,a2*)) -> sr1
  where <lookup> (tc2,x*) => (fa2*,sr2*)
      ; <not(lookup)> (tc1,sr2*)
  with <map(ta-variance)> ta1* => v1*
     ; <map(ta-type)> ta1* => a1*
     ; <zip> (fa2*,a2*) => s*
     ; sr1 := ( v1* , [ (tc1, a1*) | <S-apply(is-tvar)> (s*,sr2*) ])

rules
 
  is-subtype(|x*): (ty1,ty2) -> sub
  where is-subtype-traverse(eq;Fst,is-subtype(|x*),Swap;is-subtype(|x*),!TApp(<Fst>,<Snd>)|x*) => sub

  is-subtype-traverse(inv,cov,contrav,plus|x*): (ty1@TApp(tc1,_),ty2@TApp(tc2,a2*)) -> <plus> (tc1,a*)
  where <is-subtype(|x*)> (tc1,tc2)
      ; <lookup> (tc2,x*) => (v*,_)
      ; <upcast(|x*)> (ty1,tc2) => TApp(_,a1'*)
      ; <zip> (v*, <zip> (a1'*,a2*)) => a'*
      ; <map( ?(Invariant(),<inv>)
           <+ ?(Covariant(),<cov>)
           <+ ?(Contravariant(),<contrav>)
            )> a'* => a*

  is-subtype(|x*): (tc1,tc2) -> <id>
  where <lookup;Snd;keys> (tc1,x*) => tc1*
      ; <elem> (tc2,tc1*)

rules
  
  lub(|x*): (ty1,ty2) -> lub
  where lub-traverse(eq;Fst,lub(|x*),glb(|x*),!TApp(<Fst>,<Snd>)|x*) => lub

  lub-traverse(inv,cov,contrav,plus|x*): (ty1@TApp(tc1,_),ty2@TApp(tc2,_)) -> <plus> (tc,a*)
  where <lub(|x*)> (tc1,tc2) => tc
      ; <lookup> (tc,x*) => (v*,_)
      ; <upcast(|x*)> (ty1,tc) => TApp(_,a1'*)
      ; <upcast(|x*)> (ty2,tc) => TApp(_,a2'*)
      ; <zip> (v*, <zip> (a1'*,a2'*)) => a'*
      ; <map( ?(Invariant(),<inv>)
           <+ ?(Covariant(),<cov>)
           <+ ?(Contravariant(),<contrav>)
            )> a'* => a*

  lub(|x*): (tc1,tc2) -> tc
  where <lookup;Snd;keys;reverse> (tc1,x*) => tc1*
      ; <lookup;Snd;keys;reverse> (tc2,x*) => tc2*
      ; <common-prefix;last> (tc1*,tc2*) => tc

rules
  
  glb(|x*): (ty1,ty2) -> glb
  where glb-traverse(eq;Fst,glb(|x*),lub(|x*),!TApp(<Fst>,<Snd>)|x*) => glb

  glb-traverse(inv,cov,contrav,plus|x*): (ty1@TApp(tc1,a1*),ty2@TApp(tc2,a2*)) -> <plus> (tc,a''*)
  where id
      ; ( <is-subtype(|x*)> (tc1,tc2)
        ; !(tc1,a1*,tc2,a2*)
        + <is-subtype(|x*)> (tc2,tc1)
        ; !(tc2,a2*,tc1,a1*)
        ) => (tc,a*,tc',a'*)
  with <lookup> (tc, x*) => (v*,sr*@[(tc,fa*)|_])
      ; <lookup> (tc',sr*) => fa'*
      ; <zip;S-foldr(is-tvar,![],unify)> (fa'*,a'*) => s
      ; <zip> (v*, <zip> (a*,fa'*)) => a'*
  where <map( ?(Invariant(),<id>) ; ( !(<Fst>,<lookup> (<Snd>, s)) < inv + Fst )
           <+ ?(Covariant(),<id>) ; ( !(<Fst>,<lookup> (<Snd>, s)) < cov + Fst )
           <+ ?(Contravariant(),<id>) ; ( !(<Fst>,<lookup> (<Snd>, s)) < contrav + Fst )
            )> a'* => a''*

  glb(|x*): (tc1,tc2) -> tc
  where ( <is-subtype(|x*)> (tc1,tc2) ; !tc1
       <+ <is-subtype(|x*)> (tc2,tc1) ; !tc2
        ) => tc

rules
  
  upcast(|x*): (TApp(tc1,a1*),tc2) -> TApp(tc2,a2*)
  where <lookup> (tc1,x*) => (_,sr1*@[(tc1,fa1*)|_])
      ; <lookup> (tc2,sr1*) => fa2*
      ; <zip> (fa1*,a1*) => s*
  with <S-apply(is-tvar)> (s*,fa2*) => a2*

  all-tcs = collect-all(?TApp(<id>,_))

rules

  ta-variance: TArg(v,_) -> v
  ta-type: TArg(_,ty) -> ty
