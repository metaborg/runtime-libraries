module libanalysis2/analysis

imports

  signatures/libanalysis2/-
  runtime/analysis/core
  libanalysis2/extraction/-
  libanalysis2/positioning/-
  libanalysis2/unification/-
  libanalysis2/namebinding/-
  libanalysis2/subtyping/-
  libanalysis2/substitution/-
  libanalysis2/solver/-
  libanalysis2/prelude/-
  libanalysis2/pp

rules // analysis

  analyze(pre):
    file* -> Result(file-result*, [], [], debug-result, time-result)
  where is-list
  with file-result* := <map(analyze-one(pre))> file*
     ; debug-result := DebugResult(CollectDebugResult(-1, -1, -1, -1, -1), [], [], [])
     ; time-result := TimeResult(-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0)

  analyze-one(pre):
    File(source,source-ast,i) ->
      FileResult(source,source-ast,analyzed-ast,error*,warning*,note*)
  with (analyzed-ast,error*,warning*,note*) :=
         <do-analysis(pre);get-editor-analysis> (source,source-ast)

  analyze(pre): (source-ast,path,project-path) -> result
  where not(is-list)
  with result := <do-analysis(pre);get-editor-analysis> ($[[project-path]/[path]],source-ast)

  debug-analyze(pre): (source-ast,path,project-path) -> result
  where not(is-list)
  with result := <do-analysis(pre);get-debug-analysis> ($[[project-path]/[path]],source-ast)

rules

  do-analysis(pre):
    (source,source-ast) ->
      ( (analysed-ast, error*, warning*, note*)
        , [ ("constraints",c*)
          , ("scopegraph",g)
          , ("resolution",pr*)
          , ("solutions", sol*)
          ])
  with
    where(<debug> $[>>>>>> Analyzing [source] <<<<<<])
  ; where(<debug> ">>> Running preprocessing <<<")
  ; desugared-ast := <pre> source-ast
  ; where(<debug> ">>> Extracting constraints <<<")
  ; (annotated-ast,c*) := <extract-constraints> desugared-ast
  ; sol-i := <initial-solution>
  ; where(<debug> ">>> Solving facts <<<")
  ; [(sol-wm1,c1*)] := <solve-constraints-phase1> (sol-i,c*)
  ; g := <fromWM;sol-g> sol-wm1
  ; pr* := <resolve-all> g
  ; r* := <filterv(fromP;Hd)> pr*
  ; where(<debug> ">>> Solving constraints <<<")
  ; <solve-constraints-phase2;map(postprocess-errors)> (sol-wm1,c1*) => sol-wm*
  ; where(<debug> ">>> Processing solutions <<<")
  ; sol* := <map( ![ ("final-scopegraph", <fromWM;sol-g>)
                   , ("resolution", <fromWM;sol-r>)
                   , ("sub-types", <fromWM;sol-x>)
                   , ("pos-types", <fromWM;sol-p>)
                   , ("subst", <fromWM;sol-s>)
                   , ("errors", <wm-errors>)
                   , ("warnings", <wm-warnings>)
                   , ("notes", <wm-notes>)
                   ]
                )> sol-wm*
  ; <partition(not(is-erronious))> sol-wm* => (good-wm*, bad-wm*)
  ; n := (None(),$[Found [<length> good-wm*] correct and [<length> bad-wm*] erronious solutions.])
  ; ( ( <Hd> good-wm* <+ <Hd> bad-wm* ) => sol-wm
    < where(<debug> ">>> Found solution <<<")
    ; <fromWM;sol-r> sol-wm => r'*
    ; where(<debug> ">>> Applying name resolution <<<")
    ; resolved-ast := <apply-resolution(|<conc;mapv(Fst)> (r'*,r*))> annotated-ast
    ; <fromWM;sol-p;mapk(position-to-key)> sol-wm => p*
    ; where(<debug> ">>> Applying types <<<")
    ; typed-ast := <apply-types(|p*)> resolved-ast
    ; analysed-ast := typed-ast
    ; error* := <wm-errors;mapv(xmlencode)> sol-wm
    ; warning* := <wm-warnings;mapv(xmlencode)> sol-wm
    ; note* := [n|<wm-notes;mapv(xmlencode)> sol-wm]
    + where(<debug> ">>> No solution found <<<")
    ; analysed-ast := <apply-resolution(|<mapv(Fst)> r*)> annotated-ast
    ; error* := [(None(),"Error during analysis")]
    ; warning* := []
    ; note* := [n]
    )
  ; where(<debug> $[>>>>>> Analysis of [source] finished <<<<<<])

  get-editor-analysis = Fst

  get-debug-analysis = Snd

rules

  pp-debug-analysis: [
    ("constraints",c*)
  , ("scopegraph",g)
  , ("resolution",r)
  , ("solutions", sol*)
  ] -> Some([
    ("constraints",<filter(not(irrelevant-constraint));map(pp-Constraint)> c*)
  , ("scopegraph", <pp-Graph> g)
  , ("resolution", <pp-Resolution> r)
  , ("solutions", <map(pp-debug-analysis-solution)> sol*)
  ])

  pp-debug-analysis-solution: [
    ("final-scopegraph", g)
  , ("resolution", r*)
  , ("sub-types", x*)
  , ("pos-types", p*)
  , ("subst", s*)
  , ("errors", e*)
  , ("warnings", w*)
  , ("notes", n*)
  ] -> [
    ("final-scopegraph", <pp-Graph> g)
  , ("resolution", <map((pp-RefId,(pp-DeclId,map(pp-Term))))> r*)
  , ("sub-types", <pp-SubtypeRelation> x*)
  , ("pos-types", <filter(not(irrelevant-pos));map((pp-Pos,pp-Term))> p*)
  , ("subst", <map((pp-Var,pp-Term))> s*)
  , ("errors", <map((pp-Term,id))> e*)
  , ("warnings", <map((pp-Term,id))> w*)
  , ("notes", <map((pp-Term,id))> n*)
  ]

  irrelevant-constraint = fail
  irrelevant-pos = fail
