module libanalysis2/analysis

imports

  libstratego-sglr
  signatures/libanalysis2/-
  runtime/analysis/core
  runtime/editor/time
  runtime/index/-
  libanalysis2/extraction/-
  libanalysis2/positioning/-
  libanalysis2/unification/-
  libanalysis2/namebinding/-
  libanalysis2/subtyping/-
  libanalysis2/substitution/-
  libanalysis2/solver/-
  libanalysis2/prelude/-
  libanalysis2/pp
  editor-common.generated

rules // analysis

  analyze(pre):
    file* -> Result(file-result*, [], [], debug-result, time-result)
  where is-list
  with file-result* := <map(analyze-one(pre))> file*
     ; debug-result := DebugResult(CollectDebugResult(-1, -1, -1, -1, -1), [], [], [])
     ; time-result := TimeResult(-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0)

  analyze-one(pre):
    File(source,source-ast,i) ->
      FileResult(source,source-ast,analyzed-ast,error*,warning*,note*)
  with (analyzed-ast,error*,warning*,note*) :=
         <do-analysis(pre)> source-ast

  analyze(pre): (source-ast,path,project-path) -> result
  where not(is-list)
  with result := <do-analysis(pre)> source-ast

  get-analysis: source-ast -> <index-get-all-pairs-in-source> source
  with source := <origin-file> source-ast

rules

  do-analysis(pre):
    source-ast -> (analysed-ast, error*, warning*, note*)
  with source := <origin-file> source-ast
  with
    where(<debug> $[>>>>>> Analyzing [source] <<<<<<])
  ; index-start-collection(|source)

  ; where(<debug> ">>> Running preprocessing <<<")
  ; report-time(
      desugared-ast := <measure-time(pre,?preprocess-time)> source-ast
    )

  ; where(<debug> ">>> Extracting constraints <<<")
  ; report-time(
      (annotated-ast,c*) := <extract-constraints> desugared-ast
    ; <index-collect(|c*,source)> "constraints"
    ; sol-i := <initial-solution>
    )

  ; where(<debug> ">>> Sorting constraints <<<")
  ; report-time(
      c0* := <sort-constraints> c*
    )

  ; where(<debug> ">>> Solving facts <<<")
  ; report-time(
      [(sol-wm1,c1*)] := <solve-constraints-phase1> (sol-i,c0*)
    ; g := <fromWM;sol-g> sol-wm1
    ; <index-collect(|g,source)> "scopegraph"
    ; fr* := <resolve-all> g
    ; <index-collect(|fr*,source)> "resolution"
    ; r* := <filterv(?[<id>])> fr*
    )

  ; where(<debug> ">>> Solving constraints <<<")
  ; report-time(
      sol-wm2* := <solve-constraints-phase2;map(postprocess-errors)> (sol-wm1,c1*)
    )

  ; where(<debug> ">>> Processing solutions <<<")
  ; report-time(
      sol-wm* := <qsort((wm-errors;length,wm-errors;length);lt)> sol-wm2*
    ; sol* := <map( ![ ("scopegraph", <fromWM;sol-g>)
                     , ("ref-decl", <fromWM;sol-r>)
                     , ("sub-types", <fromWM;sol-x>)
                     , ("pos-types", <fromWM;sol-p>)
                     , ("subst", <fromWM;sol-s>)
                     , ("errors", <wm-errors>)
                     , ("warnings", <wm-warnings>)
                     , ("notes", <wm-notes>)
                     ]
                  )> sol-wm*
    ; <index-collect(|sol*,source)> "solutions"
    ; (good,bad) := <partition(not(is-erronious));(length,length)> sol-wm*
    ; status := (None(),$[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    ; ( sol-wm := <Hd> sol-wm*
      < where(<debug> ">>> Found solution <<<")
      ; <fromWM;sol-r> sol-wm => r'*
      ; where(<debug> ">>> Applying name resolution <<<")
      ; resolved-ast := <apply-resolution(|<conc;mapv(Fst)> (r'*,r*))> annotated-ast
      ; <fromWM;sol-p;mapk(position-to-key)> sol-wm => p*
      ; where(<debug> ">>> Applying types <<<")
      ; typed-ast := <apply-types(|p*)> resolved-ast
      ; analysed-ast := typed-ast
      ; error* := <wm-errors;mapv(xmlencode)> sol-wm
      ; warning* := <wm-warnings;mapv(xmlencode)> sol-wm
      ; note* := [status|<wm-notes;mapv(xmlencode)> sol-wm]
      + where(<debug> ">>> No solution found <<<")
      ; analysed-ast := <apply-resolution(|<mapv(Fst)> r*)> annotated-ast
      ; error* := [(None(),"Found no correct or erronious solutions.")]
      ; warning* := []
      ; note* := [status]
      )
    )

  ; index-stop-collection(|source)
  ; where(<debug> $[>>>>>> Analysis of [source] finished <<<<<<])

rules

  report-time(s) = measure-time(s,where(<debug> $[Finished in [<cputime-to-seconds;real-to-string(|2)>]s]))

rules

  pp-analysis = map(pp-analysis-component) ; !Some(<id>)

  pp-analysis-component: ("constraints",_) -> <(id,filter(not(irrelevant-constraint));map(pp-Constraint))>
  pp-analysis-component: ("scopegraph",_)  -> <(id,pp-Graph)>
  pp-analysis-component: ("resolution",_) -> <(id,pp-Resolution)>
  pp-analysis-component: ("ref-decl",_) -> <(id,pp-RefDecl)>
  pp-analysis-component: ("sub-types",_) -> <(id,pp-SubtypeRelation)>
  pp-analysis-component: ("pos-types",_) -> <(id,filter(not(irrelevant-pos));map((pp-Pos,pp-Term)))>
  pp-analysis-component: ("subst",_) -> <(id,map((pp-Var,pp-Term)))>
  pp-analysis-component: ("errors",_) -> <(id,map((pp-Term,id)))>
  pp-analysis-component: ("warnings",_) -> <(id,map((pp-Term,id)))>
  pp-analysis-component: ("notes",_) -> <(id,map((pp-Term,id)))>
  pp-analysis-component: ("solutions",_) -> <(id,map(pp-analysis))>
  pp-analysis-component: (_,_) -> <(id,pp-Term)>
    where Fst;debug(!"pp-analysis-component undefined for ")

  pp-RefDecl = map((pp-RefId,(pp-DeclId,map(pp-Term))))

  irrelevant-constraint = fail
  irrelevant-pos = fail
