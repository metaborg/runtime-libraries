module libanalysis2/unification/solver

imports
  libanalysis2/unification/-
  libanalysis2/namebinding/-
  libanalysis2/solver/-
  libanalysis2/prelude/-
  libanalysis2/pp
  signatures/libanalysis2/-

rules
  
  solve-constraint: (CEqual(t,t,_),sol-wm) -> [(sol-wm,[])]

  solve-constraint: (CEqual(t,v@Var(_),msginfo),sol-wm) -> [(sol-wm,[CEqual(v,t,msginfo)])]
  where <not(is-var)> t

  solve-constraint: (CEqual(v@Var(_),t,msginfo),sol-wm) -> [(sol-wm',[])]
  with ( <var-occurs> (v,t)
       < msg := [v," occurs in ",t]
       ; <add-message(|msginfo,msg)> sol-wm
       + <sol-wm-apply-s> ([(v,t)],sol-wm)
       ) => sol-wm'

  solve-constraint: (CEqual(Sub(_),Sub(_),msginfo),sol-wm) -> [(sol-wm',[])]
  with msg := "Unify subtitutions is forbidden"
     ; sol-wm' := <add-message(|msginfo,msg)> sol-wm

  solve-constraint: (CEqual(t1@c1#(a1),t2@c2#(a2),msginfo),sol-wm) -> [(sol-wm',[])]
  where <not(is-op)> t1
      ; <not(is-op)> t2
      ; ( <not(eq)> (c1,c2) 
       <+ <(length,length);not(eq)> (a1,a2)
        )
  with msg := <default-unify-error(|t1,t2)>
     ; sol-wm' := <add-message(|msginfo,msg)> sol-wm

  solve-constraint: (CEqual(t1@c#(a1),t2@c#(a2),msginfo),sol-wm) -> [(sol-wm,c*)]
  where <not(is-op)> t1
      ; <(length,length);eq> (a1,a2)
  with msg := <default-unify-error(|t1,t2)>
     ; msginfo' := <default-message(|msg)> msginfo
     ; c* := <zip(!CEqual(<Fst>,<Snd>,msginfo'))> (a1,a2)

rules

  default-unify-error(|t1,t2) = !["Cannot not unify ",t1," with ",t2]

  unsolved-message: CEqual(t1,t2,msginfo) -> <default-message(|msg)> msginfo
  with msg := <default-unify-error(|t1,t2)>
