module libanalysis2/namebinding/resolution

imports
  libanalysis2/namebinding/-
  libanalysis2/pp
  libanalysis2/prelude/-
  signatures/libanalysis2/namebinding/-
  signatures/libanalysis2/solver/-

signature

  // type Env = Partial [(Name,[(Decl,Path)])]

rules

  // resolve-all :: Graph -> [(Ref,[(Decl,Path)])]
  resolve-all =
    ?g
  ; G-refs
  ; filter(!(<id>,<resolve(|g)>))

  // resolve(|Graph) :: Ref -|-> [(Decl,Path)]
  resolve(|g) = resolve(|g,[])

rules // resolution internal

  // resolve :: Ref -|-> [(Decl,Path)]
  resolve(|g,ir*) =
    with(dbg-res(|"resolve "))
  ; ?r
  ; ( <G-scope> (g,r) // :: Scope
   <+ <debug(!"ERROR: Cannot get scope for reference ");fail> r
    )
  ; env(|<labels-wf<+default-labels-wf>,g,[r|ir*],[]) // :: Env
  ; ( <lookup> (<id-atom> r,<fromP>) // :: [(Decl,Path)]
   <+ fromTotal ; ![]
    ) // :: [(Decl,Path)]
  ; with(dbg-res(|"resolve = "))



  // env(|RE,Graph,[Ref],[Scope]) :: Scope -> Env
  env(|re,g,ir*,is*) =
    with(dbg-res(|"env "))
  ; ?s
  ; ( (<elem> (s,is*) + <emptiness> re)
    < <pureP> []
    + <env_L(|[D(),I(),P()|<labels<+![]>],re,g,ir*,is*)> s
    )
  ; with(dbg-res(pp-Env|"env = "))



  // env(|[Label],RE,Graph,[Ref],[Scope]) :: Scope -> Env
  env_L(|L,re,g,ir*,is*) =
    where(<is-list> L)
  ; with(dbg-res(|"env^L "))
  ; ?s
  ; <max-labels> L
  ; map(\ l -> <env-shadow> ( <env_L(|<labels-lt(|l)> L,re,g,ir*,is*)> s
                            , <env_l(|l,re,g,ir*,is*)> s
                            ) \)
  ; env-unions
  ; with(dbg-res(pp-Env|"env^L = "))



  // env(|D(),RE,Graph,[Ref],[Scope]) :: Scope -> Env
  env_l(|l,re,g,ir*,is*) =
    where(D() := l)
  ; with(dbg-res(|"env^D "))
  ; ?s
  ; ( Empty() := <nullable> re
    < ![]
    + <G-decls;map(\ d -> (d,[D(d)]) \)> (g,s)
    ; group(Fst;id-atom)
    ) ; pureP
  ; with(dbg-res(pp-Env|"env^D = "))



  // env(|Label,RE,Graph,[Ref],[Scope]) :: Scope -> Env
  env_l(|l,re,g,ir*,is*) =
    with(dbg-res(|"env^l "))
  ; ?s
  ; ( <union> ( <iss(|l,g)> s
              , <irs(|l,g,ir*)> s
              )
    < map(\ (s',step) -> e' where
              e  := <env(|<deriv(|l)> re,g,ir*,[s|is*])> s'
            ; e' := <env-prepend(|step)> e \)
    ; env-unions
    + !Partial([])
    )
  ; with(dbg-res(pp-Env|"env^l = "))

  // iss(|Graph,[Ref]) :: Scope -|-> [(Scope,Step)]
  iss(|l,g) =
    with(dbg-res(|"iss^l "))
  ; ?s
  ; <G-s-imports> (g,s) // :: [(Label,Scope,Term)]
  ; map(where(Snd;is-ground))
  ; filter(?(l,_,_);!(<Snd>,<Third>)) // :: [(Scope,Term)]
  ; map(\ (s',t) -> (s',E(l,s',t)) \) // :: [(Scope,Step)]
  ; with(dbg-res(|"iss^l = "))

  // irs(|Graph,[Ref]) :: Scope -|-> [(Scope,Step)]
  irs(|l,g,ir*) =
    with(dbg-res(|"irs^l "))
  ; ?s
  ; <G-r-imports> (g,s) // :: [(Label,Ref,Term)]
  ; filter(?(l,_,_);!(<Snd>,<Third>)) // :: [(Ref,Term)]
  ; filterk(\ r -> r where <not(elem)> (r,ir*) \) // :: [(Ref,Term)]
  ; mapconcat(\ (r,t) -> <resolve(|g,ir*);mapv(!(r,t))> r \) // :: [(Decl,(Ref,Term))]
  ; filter(\ (d,(r,t)) -> (s',N(l,r,s',t)) where s' := <G-assoc> (g,d) \) // :: [(Scope,Step)]
  ; with(dbg-res(|"irs^l = "))



  // shadow :: (Env, Env) -> Env
  env-shadow =
    twrapP // :: Partial ([(Name,[(Decl,Path)])], [(Name,[(Decl,Path)])])
  ; fmap(merge(union,Fst)) // :: Env

  // shadow :: [Env] -> Env
  env-unions =
    sequenceP // :: [[(Name,[(Decl,Path)])]]
  ; fmap(foldr(![],merge(union,union))) // :: Env

  // env-prepend(|Step) = Env -> Env
  env-prepend(|step) = fmap(mapv(map(\ (d,p) -> (d,[step|p]) \)))



rules
 
  path-labels = filter(step-label)

  step-label = ?E(_,_,<not(?None())>) 
  step-label = ?N(_,_,_,<not(?None())>) 

  get-names(|g): Declarations(ns,s) -> <G-decls;filter-ns(|ns)> (g,s)
  get-names(|g): References(ns,s) -> <G-refs;filter-ns(|ns)> (g,s)
  get-names(|g): Visibles(ns,s) -> <env(|<labels-wf<+default-labels-wf>,g,[],[]);fromTotal;values;concat;map(Fst);filter-ns(|ns)> s
 
  pp-Env = fmap(map((pp-Name,map((pp-DeclId,pp-Path)))))

  dbg-res(s|n) = id // s ; debug(!n)
  dbg-res(|n) = dbg-res(id|n)
  dbg-res(s) = dbg-res(s|"")
