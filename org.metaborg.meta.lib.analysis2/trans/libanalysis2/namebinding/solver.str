module libanalysis2/namebinding/solver

imports
  
  libanalysis2/namebinding/-
  libanalysis2/prelude/-
  libanalysis2/solver/-
  libanalysis2/pp
  signatures/libanalysis2/equality/-
  signatures/libanalysis2/namebinding/-

rules
 
  solve-fact = solve-namebinding-fact 
 
  solve-namebinding-fact: (FDecl(d,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-decl> (g,s,d) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-namebinding-fact: (FRef(r,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-ref> (g,s,r) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-namebinding-fact: (FImportR(l,r,t,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-r-import> (g,s,(l,r,t)) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-namebinding-fact: (FImportS(l,s',t,s),sol-wm) -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-s-import> (g,s,(l,s',t)) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  solve-namebinding-fact: (FAssoc(d,s),sol-wm)    -> [(sol-wm',[])]
  with <fromWM;sol-g> sol-wm => g
     ; <G-with-assoc> (g,d,s) => g'
     ; <fmap(<sol-with-g> (g',<id>))> sol-wm => sol-wm'

  constraint-priority: FDecl(_,_) -> 3
  constraint-priority: FRef(_,_) -> 3
  constraint-priority: FImportR(_,_,_,_) -> 3
  constraint-priority: FImportS(_,_,_,_) -> 3
  constraint-priority: FAssoc(_,_) -> 3

rules

  solve-constraint = solve-namebinding-constraint

  solve-namebinding-constraint: (CResolves(r,l,d,msginfo),sol-wm) -> [(sol-wm,c*)]
  where r* := <fromWM;sol-r> sol-wm
      ; (d',p) := <lookup> (r,r*)
      ; l' := <path-labels> p
  with msg := ["Unable to resolve ",r," to ",d]
     ; msginfo' := <default-message(|msg)> msginfo
     ; c* := [ CEqual(d,d',msginfo'),
               CEqual(l,l',msginfo')
             ]

  solve-namebinding-constraint: (CResolves(r,l,d,msginfo),sol-wm) -> res*
  where r* := <fromWM;sol-r> sol-wm
      ; <not(lookup)> (r,r*)
      ; g := <fromWM;sol-g> sol-wm
      ; dl*@[_|_] := <resolve(|g)> r
  with msg := ["Unable to resolve ",r," to ",d]
     ; msginfo' := <default-message(|msg)> msginfo
     ; <map(solve-namebinding-constraint-step(|r,l,d,msginfo',sol-wm))> dl* => res*

  solve-namebinding-constraint-step(|r,l,d,msginfo,sol-wm): (d',p) -> (sol-wm',c*)
  with <fmap(sol-set-r(|r,(d',p)))> sol-wm => sol-wm'
  with l' := <path-labels> p
  with c* := [ CEqual(d,d',msginfo)
             , CEqual(l,l',msginfo)
             ]
 
  solve-namebinding-constraint: (CAssoc(d,s,msginfo),sol-wm) -> [(sol-wm,c*)]
  where <is-ground> d
      ; g := <fromWM;sol-g> sol-wm
      ; s' := <G-assoc> (g,d)
  with msg := ["Cannot find scope ",s," associated with ",d]
     ; c* := [ CEqual(s,s',<default-message(|msg)> msginfo) ]
 
  solve-namebinding-constraint: (CDistinct(N,msginfo),sol-wm) -> [(sol-wm',[])]
  where <is-ground> N
      ; g := <fromWM;sol-g> sol-wm
      ; n* := <get-names(|g)> N
  with n'* := <dups(id-eq)> n*
     ; ( ?[]
       < !sol-wm
       + msg := "Duplicate name"
       ; <add-message(|<default-names-pos(|n'*)> msginfo,msg)> sol-wm
       ) => sol-wm'

  solve-namebinding-constraint: (CSubset(N1,N2,msginfo),sol-wm) -> [(sol-wm',[])]
  where <is-ground> N1
      ; <is-ground> N2
      ; g := <fromWM;sol-g> sol-wm
      ; n1* := <get-names(|g)> N1
      ; n2* := <get-names(|g)> N2
  with n'* := <diff(id-eq)> (n1*,n2*)
     ; ( ?[]
       < !sol-wm
       + msg := "Missing name"
       ; <add-message(|<default-names-pos(|n'*)> msginfo,msg)> sol-wm
       ) => sol-wm'

  solve-namebinding-constraint: (CDisjoint(N1,N2,msginfo),sol-wm) -> [(sol-wm',[])]
  where <is-ground> N1
      ; <is-ground> N2
      ; g := <fromWM;sol-g> sol-wm
      ; n1* := <get-names(|g)> N1
      ; n2* := <get-names(|g)> N2
  with n'* := <isect(id-eq)> (n1*,n2*)
     ; ( ?[]
       < !sol-wm
       + msg := "Duplicate name"
       ; <add-message(|<default-names-pos(|n'*)> msginfo,msg)> sol-wm
       ) => sol-wm'

rules

  constraint-priority: CAssoc(_,_,_) -> 4
  constraint-priority: CResolves(_,_,_,_) -> 4
  constraint-priority: CDistinct(_,_) -> 4
  constraint-priority: CSubset(_,_,_) -> 4
  constraint-priority: CDisjoint(_,_,_) -> 4

rules
 
  default-names-pos(|n*) =
    try(Message(id,?None(),!NAMES()))
  ; Message(id,bottomup(try(?NAMES();<map(id-name)> n*)),try(?NAMES();<map(position-to-term)> n*))
 
  unsolved-message: CResolves(r,l,d,msginfo) -> <default-message(|msg)> msginfo
  with msg := ["Cannot resolve ",r," to ",d]

  unsolved-message: CAssoc(d,s,msginfo) -> <default-message(|msg)> msginfo
  with msg := ["Cannot find associated scope ",s," of ",d]

  unsolved-message: CDistinct(n,msginfo) -> <default-message(|msg)> msginfo
  with msg := ["Cannot check if ",n," are distinct"]

  unsolved-message: CSubset(n1,n2,msginfo) -> <default-message(|msg)> msginfo
  with msg := ["Cannot check if ",n1," in ",n2]

  unsolved-message: CDisjoint(n1,n2,msginfo) -> <default-message(|msg)> msginfo
  with msg := ["Cannot check if ",n1," disjoint from ",n1]
