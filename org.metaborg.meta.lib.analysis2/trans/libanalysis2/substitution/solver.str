module libanalysis2/substitution/solver

imports
  libanalysis2/equality/functions
  libanalysis2/prelude/-
  libanalysis2/solver/-
  libanalysis2/typechecking/functions
  libanalysis2/pp
  signatures/libanalysis2/equality/-
  signatures/libanalysis2/substitution/-
  signatures/libanalysis2/typechecking/-

rules

  get-S: Sub(s) -> s

  get-Ts: TList(t*) -> t*

  solve-constraint: (c@CMkSub(s,d*,r*,msginfo),sol-wm) -> [(sol-wm',c*)]
  where <is-var> s
      ; <not(is-var)> d*
      ; <not(is-var)> r*
  with dt* := <get-Ts> d*
     ; rt* := <get-Ts> r*
     ; ( <(length,length);eq> (dt*,rt*)
       < s' := Sub(<zip> (dt*, rt*))
       ; msg := ["Could not build substitution ",s," from ",s']
       ; !(sol-wm, [CEqual(s,s',<detail-message(|msg)> msginfo)])
       + msg := ["Different number of parameters ",rt*," and ",dt*]
       ; !(<add-message(detail-message(|msg)|msginfo)> sol-wm, [])
       ) => (sol-wm',c*)

  solve-constraint: (c@CComposeSub(s,s*,msginfo),sol-wm) -> [(sol-wm,c*)]
  where <is-var> s
      ; <not(is-var);map(not(is-var))> s*
  with s' := <map(get-S);S-compose(is-tvar)> s*
     ; msg := ["Could not compose ",s," and ",s']
     ; c* := [CEqual(s,s',<detail-message(|msg)> msginfo)]

  solve-constraint: (c@CApplySub(ty,s,ty',msginfo),sol-wm) -> [(sol-wm,c*)]
  where <not(is-var)> s
  with ty'' := <S-apply(is-tvar)> (<get-S> s,ty')
     ; c* := [CEqual(ty,ty'',msginfo)]

rules

  constraint-priority: CMkSub(_,_,_,_) -> 1
  constraint-priority: CComposeSub(_,_,_) -> 1
  constraint-priority: CApplySub(_,_,_,_) -> 1