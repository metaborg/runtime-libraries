module libanalysis2/Analysis

imports

  libanalysis2/Common

context-free syntax

  Var.Var                   = <v<Int>>

  Scope.Global              = <global>
  Scope.Scope               = <scope(<Int>)>
  Scope                     = Var

  OptionScope.None          = <->
  OptionScope               = Scope

  DeclId.DeclId             = <decl(<Namespace>,<String>,<KeyPos>)>
  DeclId                    = Var

  RefId.RefId               = <ref(<Namespace>,<String>,<KeyPos>)>

  KeyPos.Pos                = <<String>@(<String>,<Int>,<Int>,<Int>,<Int>)>

  Namespace.None            = <->
  Namespace.Namespace       = String

  Atom.Atom                 = <atom(<Namespace>,<String>)>

context-free syntax

  Type.TApp                 = <<TypeCon>[<{Type ","}*>]>
  Type.TVar                 = <'<String>>
  Type.TList                = <Type[<{Type ", "}*>]>
  Type                      = Var

  TypeDef.TDef              = <<TypeCon>[<{TypeArg ","}*>]>
  TypeArg.TArg              = <<Variance><Type>>

  Variance.Invariant        = <=>
  Variance.Covariant        = <+>
  Variance.Contravariant    = <->

  TypeCon                   = NotImplemented

context-free syntax // base
  
  MessageKind.Error         = <error>
  MessageKind.Warning       = <warning>
  MessageKind.Note          = <note>

  MessageContent.None       = <default>
  MessageContent            = {Term ""}*
  MessageContent            = Term

  Message.Message           = <<MessageKind>=[<MessageContent>]<TermPos>>

  EditorMessages            = {EditorMessage "\n"}*
  EditorMessage             = <<Term> : <String>>

  Constraint.CTrue          = <True>
  Constraint.CAndStar       = <<{Constraint "/\\"}*>> {longest-match}

context-free syntax // equality

  Constraint.CEqual         = [[Term] == [Term] [Message]]

  Subst      = {SubstEntry "\n"}*
  SubstEntry = [[Var] |--> [Term]]

context-free syntax // types

  Constraint.CTypeOf        = <<Pos> : <Type> <Message>>

  PosType = {PosTypeEntry "\n"}*
  PosTypeEntry = <<Pos> : <Type>>

  Pos                       = KeyPos
  Pos                       = DeclId
  Pos                       = RefId

context-free syntax // scope graph

  Graph.G = <
    scope graph {
      <{ScopeEntry "\n"}*>
      assocs = <{AssocEntry "\n"}*>
    }
  >
 
  ScopeEntry = <<Scope> = <ScopeImpl>>
 
  ScopeImpl.S = <
    {
      parent    = <OptionScope>
      decls     = <{DeclId ", "}*>
      refs      = <{RefId ", "}*>
      r-imports = <{ImportREntry ", "}*>
      s-imports = <{ImportSEntry ", "}*>
    }
  >
 
  ImportREntry = <<RefId>/<Term>>
  ImportSEntry = <<Scope>/<Term>>
  AssocEntry = <<DeclId> : <Scope>>

  Resolution = {ResolutionEntry "\n"}*
  ResolutionEntry = <<RefId> <{Resolved "\n"}*>>
  Resolved = [|--> [DeclId]/[{Term ","}*]]

context-free syntax // name resolution

  Constraint.FParent        = <parent(<Scope>) is <OptionScope>>
  Constraint.FDecl          = <<DeclId> in <Scope>>
  Constraint.FRef           = <<RefId> in <Scope>>
  Constraint.FImportR       = <import <RefId>/<Term> in <Scope>>
  Constraint.FImportS       = <import <Scope>/<Term> in <Scope>>
  Constraint.FAssoc         = <<DeclId> with <Scope>>

  Constraint.CAssoc         = [[DeclId] ~~> [Scope] [Message]]
  Constraint.CResolves      = [[RefId] |-[Term]-> [DeclId] [Message]]
  Constraint.CDistinct      = <distinct <Scope> <Message>>
  Constraint.CInit          = <init <Scope> <Message>>

  RefDecl = {RefDeclEntry "\n"}*
  RefDeclEntry = [[RefId] [Resolved]]

context-free syntax // subtyping

  Constraint.FSubType       = [[TypeDef] <: [Type] [Message]]

  Constraint.CSubType       = [[Type] <= [Type] [Message]]
  Constraint.CLubType       = [[Type] == lub([Type],[Type]) [Message]]

  SubtypingRelation = {SubtypingEntry "\n"}*
  SubtypingEntry    = [[TypeCon][SubtypingEntry2]]
  SubtypingEntry2   = [[SubtypingEntry3] <: [{Supertype " <: "}*]]
  SubtypingEntry3   = <[<{TypeArg ","}*>]>
  Supertype         = <<TypeCon>[<{Type ","}*>]>
  
context-free syntax // substitutions

  Constraint.CMkSub         = [[Substitution] == [Type] |-->* [Type] [Message]]
  Constraint.CComposeSub    = <<Substitution> == <{Substitution " . "}+> <Message>>
  Constraint.CApplySub      = <<Type> == <Substitution>.<Type> <Message>>

  Mapping                   = [[Type] |--> [Type]]

  Substitution.Sub          = <{<{Mapping ","}*>}>
  Substitution              = Var
