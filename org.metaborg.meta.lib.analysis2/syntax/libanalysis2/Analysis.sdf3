module libanalysis2/Analysis

imports

  libanalysis2/Common

context-free syntax

  Var.Var                   = <v<Int>>

  Scope.Global              = <global>
  Scope.Scope               = <scope(<Int>)>
  Scope                     = Var

  OptionScope.None          = <->
  OptionScope               = Scope

  DeclId.DeclId             = <decl(<Namespace>,<String>,<KeyPos>)>
  DeclId                    = Var

  RefId.RefId               = <ref(<Namespace>,<String>,<KeyPos>)>

  KeyPos.Pos                = <<String><TermPos>>

  Namespace.None            = <->
  Namespace.Namespace       = String

  Name.Name                 = <name(<Namespace>,<String>)>

context-free syntax

  Type.TApp                 = <<TypeCon>[<{Type ","}*>]>
  Type.TVar                 = <'<String>>
  Type.TList                = <Type[<{Type ", "}*>]>
  Type                      = Var

  TypeDef.TDef              = <<TypeCon>[<{TypeArg ","}*>]>
  TypeArg.TArg              = <<Variance><Type>>

  Variance.Invariant        = <=>
  Variance.Covariant        = <+>
  Variance.Contravariant    = <->

  TypeCon                   = NotImplemented

context-free syntax // base
  
  MessageKind.Error         = <error>
  MessageKind.Warning       = <warning>
  MessageKind.Note          = <note>

  MessageContent.None       = <default>
  MessageContent            = {Term ""}*
  MessageContent            = Term

  Message.Message           = <<MessageKind>=[<MessageContent>]<TermPos>>

  EditorMessage             = <<Term> : <String>>

  Constraint.CTrue          = <True>
  Constraint.CAndStar       = <<{Constraint "/\\"}*>> {longest-match}

  Analysis                   = {AnalysisResult "\n\n"}*
  AnalysisResult.Constraints = <
    constraints :=
      <{Constraint "\n"}*>
  >
  AnalysisResult.Errors = <
    errors :=
      <{EditorMessage "\n"}*>
  >
  AnalysisResult.Warnings = <
    warnings :=
      <{EditorMessage "\n"}*>
  >
  AnalysisResult.Notes = <
    notes :=
      <{EditorMessage "\n"}*>
  >
  AnalysisResult.AlternativeSolutions = <
    alternative solutions := 
      <{AlternativeSolution "\n\n"}*>
  >
  AlternativeSolution = <[<Int> <Analysis>]>

context-free syntax // equality

  Constraint.CEqual         = [[Term] == [Term] [Message]]

  AnalysisResult.Substitution = <
    substitution := 
      <{Substitution "\n"}*>
  >
  Substitution = [[Var] |--> [Term]]

context-free syntax // types

  Constraint.CTypeOf        = <<Pos> : <Type> <Message>>

  Pos                       = KeyPos
  Pos                       = DeclId
  Pos                       = RefId

  AnalysisResult.PositionTypes = <
    position types :=
      <{PositionType "\n"}*>
  >
  PositionType = <<Pos> : <Type>>

context-free syntax // scope graph

  Graph.G = <
    scope graph {
      <{ScopeEntry "\n"}*>
      assocs = <{AssocEntry "\n"}*>
    }
  >
 
  ScopeEntry = <<Scope> = <ScopeImpl>>
 
  ScopeImpl.S = <
    {
      parent    = <OptionScope>
      decls     = <{DeclId ", "}*>
      refs      = <{RefId ", "}*>
      r-imports = <{ImportREntry ", "}*>
      s-imports = <{ImportSEntry ", "}*>
    }
  >
 
  ImportREntry = <<RefId>/<Term>>
  ImportSEntry = <<Scope>/<Term>>
  AssocEntry = <<DeclId> : <Scope>>

  AnalysisResult.InitialScopeGraph = <
    initial scope graph :=
      <Graph>
  >

  AnalysisResult.InitialResolution = <
    initial name resolution := 
      <{FullResolution "\n"}*>
  >

  FullResolution = <<RefId> <{Resolved "\n"}*>>
  Resolved        = [
    |--> [DeclId]
         path = [Path]
  ]

  Path            = {Step "\n"}*
  Step.D          = <D(<DeclId>)>
  Step.E          = <E(<Label>,<Scope>)/<Term>>
  Step.N          = <N(<Label>,<RefId>,<Scope>)/<Term>>
  Label.I         = <I>
  Label.P         = <P>

context-free syntax // name resolution

  Constraint.FParent        = <parent(<Scope>) is <OptionScope>>
  Constraint.FDecl          = <<DeclId> in <Scope>>
  Constraint.FRef           = <<RefId> in <Scope>>
  Constraint.FImportR       = <import <RefId>/<Term> in <Scope>>
  Constraint.FImportS       = <import <Scope>/<Term> in <Scope>>
  Constraint.FAssoc         = <<DeclId> with <Scope>>

  Constraint.CAssoc         = [[DeclId] ~~> [Scope] [Message]]
  Constraint.CResolves      = [[RefId] |-[Labels]-> [DeclId] [Message]]

  Labels = <[<{Term ","}*>]>
  Labels = Var

  AnalysisResult.ScopeGraph = <
    scope graph :=
      <Graph>
  >
  
  AnalysisResult.Resolution = <
    name resolution := 
      <{OneResolution "\n"}*>
  >
  
  OneResolution = [[RefId] [Resolved]]

context-free syntax // name sets

  Constraint.CDistinct      = <!<Names> <Message>>
  Constraint.CSubset        = <<Names> in <Names> <Message>>
  Constraint.CDisjoint      = <<Names> # <Names> <Message>>
  
  Names.Declarations  = <D(<Namespace>,<Scope>)>
  Names.References    = <R(<Namespace>,<Scope>)>
  Names.Visibles      = <V(<Namespace>,<Scope>)>

  Placeholder.NAMES   = <NAMES>

context-free syntax // subtyping

  Constraint.FSubType       = [[TypeDef] <: [Type] [Message]]

  Constraint.CSubType       = [[Type] <= [Type] [Message]]
  Constraint.CLubType       = [[Type] == lub([Type],[Type]) [Message]]

  AnalysisResult.SubtypingRelation = <
    subtyping relation := 
      <{SubtypingEntry "\n"}*>
    >
  SubtypingEntry    = [[TypeCon][SubtypingEntry2]]
  SubtypingEntry2   = [[SubtypingEntry3] <: [{Supertype " <: "}*]]
  SubtypingEntry3   = <[<{TypeArg ","}*>]>
  Supertype         = <<TypeCon>[<{Type ","}*>]>
  
context-free syntax // substitutions

  Constraint.CMkSub         = [[TypeSubstitution] == [Type] |-->* [Type] [Message]]
  Constraint.CComposeSub    = <<TypeSubstitution> == <{TypeSubstitution " . "}+> <Message>>
  Constraint.CApplySub      = <<Type> == <TypeSubstitution>.<Type> <Message>>

  Mapping                   = [[Type] |--> [Type]]

  TypeSubstitution.Sub      = <{<{Mapping ","}*>}>
  TypeSubstitution          = Var
